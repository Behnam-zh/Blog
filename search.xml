<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>图中的环</title>
      <link href="/2024/07/19/%E5%8C%BA%E9%97%B4%E5%90%88%E5%B9%B6/"/>
      <url>/2024/07/19/%E5%8C%BA%E9%97%B4%E5%90%88%E5%B9%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="一、题目"><a href="#一、题目" class="headerlink" title="一、题目"></a>一、题目</h2><blockquote><p>题目链接：<a href="https://www.acwing.com/problem/content/805/">https://www.acwing.com/problem/content/805/</a></p></blockquote><p>给定 $n$ 个区间 $[l_i, r_i]$，要求合并所有有交集的区间。</p><p>注意如果在端点处相交，也算有交集。</p><p>输出合并完成后的区间个数。</p><p>例如：$[1,3]$ 和 $[2,6]$ 可以合并为一个区间 $[1,6]$。</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行包含整数 $n$。</p><p>接下来 $n$ 行，每行包含两个整数 $l$ 和 $r$。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>共一行，包含一个整数，表示合并区间完成后的区间个数。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>$1 \le n \le 100000$,<br>$-10^9 \le l_i \le r_i \le 10^9$</p><h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">1 2</span><br><span class="line">2 4</span><br><span class="line">5 6</span><br><span class="line">7 8</span><br><span class="line">7 9</span><br></pre></td></tr></table></figure><h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure><h2 id="二、题解"><a href="#二、题解" class="headerlink" title="二、题解"></a>二、题解</h2><h4 id="1-区间合并"><a href="#1-区间合并" class="headerlink" title="1. 区间合并"></a>1. 区间合并</h4><h4 id="2-vector排序"><a href="#2-vector排序" class="headerlink" title="2. vector&lt;PII&gt;排序"></a>2. <code>vector&lt;PII&gt;</code>排序</h4><h2 id="三、代码"><a href="#三、代码" class="headerlink" title="三、代码"></a>三、代码</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">typedef pair&lt;int, int&gt; PII;</span><br><span class="line"></span><br><span class="line">int n;</span><br><span class="line">vector&lt;PII&gt; qj; </span><br><span class="line"></span><br><span class="line">void merge(vector&lt;PII&gt; &amp;qqj)</span><br><span class="line">&#123;</span><br><span class="line">    vector&lt;PII&gt; ans;</span><br><span class="line">    sort(qqj.begin(), qqj.end());</span><br><span class="line">    int st = -2e9, ed = -2e9;</span><br><span class="line">    for (auto it : qqj)</span><br><span class="line">    &#123;</span><br><span class="line">        if (it.first &gt; ed)</span><br><span class="line">        &#123;</span><br><span class="line">            if (st != -2e9) ans.push_back(&#123;st, ed&#125;);</span><br><span class="line">            st = it.first, ed = it.second;</span><br><span class="line">        &#125;</span><br><span class="line">        else ed = max(ed, it.second);</span><br><span class="line">    &#125;</span><br><span class="line">    if (st != -2e9) ans.push_back(&#123;st, ed&#125;);</span><br><span class="line">    qqj = ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    while ( n -- )</span><br><span class="line">    &#123;</span><br><span class="line">        int l, r;</span><br><span class="line">        cin &gt;&gt; l &gt;&gt; r;</span><br><span class="line">        qj.push_back(&#123;l, r&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    merge(qj);</span><br><span class="line">    cout &lt;&lt; qj.size() &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> AcWing </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 区间合并 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图中的环</title>
      <link href="/2024/07/17/%E5%9B%BE%E4%B8%AD%E7%9A%84%E7%8E%AF/"/>
      <url>/2024/07/17/%E5%9B%BE%E4%B8%AD%E7%9A%84%E7%8E%AF/</url>
      
        <content type="html"><![CDATA[<h2 id="一、题目"><a href="#一、题目" class="headerlink" title="一、题目"></a>一、题目</h2><blockquote><p>题目链接：<a href="https://www.acwing.com/problem/content/description/4219/">https://www.acwing.com/problem/content/description/4219/</a></p></blockquote><p>给定一个 $n$ 个点 $m$ 条边的<strong>无向图</strong>。</p><p>点的编号从 $1$ 到 $n$。</p><p>图中不含重边和自环。</p><p>请你对给定图进行判断，如果该图是一个<strong>有且仅有</strong>一个环的<strong>连通图</strong>，则输出 <code>YES</code>，否则输出 <code>NO</code>。</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行包含两个整数 $n,m$。</p><p>接下来 $m$ 行，每行包含两个整数 $a,b$，表示点 $a$ 和点 $b$ 之间存在一条<strong>无向边</strong>。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>如果该图是一个<strong>有且仅有</strong>一个环的<strong>连通图</strong>，则输出 <code>YES</code>，否则输出 <code>NO</code>。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>前三个测试点满足 $1 \le n \le 10$。<br>所有测试点满足 $1 \le n \le 100$，$0 \le m \le \frac{n(n-1)}{2}$，$1 \le a,b \le n$。</p><h4 id="输入样例1："><a href="#输入样例1：" class="headerlink" title="输入样例1："></a>输入样例1：</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">6 6</span><br><span class="line">6 3</span><br><span class="line">6 4</span><br><span class="line">5 1</span><br><span class="line">2 5</span><br><span class="line">1 4</span><br><span class="line">5 4</span><br></pre></td></tr></table></figure><h4 id="输出样例1："><a href="#输出样例1：" class="headerlink" title="输出样例1："></a>输出样例1：</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">YES</span><br></pre></td></tr></table></figure><h4 id="输入样例2："><a href="#输入样例2：" class="headerlink" title="输入样例2："></a>输入样例2：</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">6 5</span><br><span class="line">5 6</span><br><span class="line">4 6</span><br><span class="line">3 1</span><br><span class="line">5 1</span><br><span class="line">1 2</span><br></pre></td></tr></table></figure><h4 id="输出样例2："><a href="#输出样例2：" class="headerlink" title="输出样例2："></a>输出样例2：</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">NO</span><br></pre></td></tr></table></figure><h2 id="二、题解"><a href="#二、题解" class="headerlink" title="二、题解"></a>二、题解</h2><h3 id="1-基环树"><a href="#1-基环树" class="headerlink" title="1. 基环树"></a>1. 基环树</h3><p>如下图所示，基环树中只有一个环，且整个图是联通的。可以推断出它的性质：连通图；节点数&#x3D;边数。</p><p><img src="https://cdn.jsdelivr.net/gh/ihrd/Picture/image-20240717211813659.png" alt="image-20240717211813659"></p><h3 id="2-并查集"><a href="#2-并查集" class="headerlink" title="2. 并查集"></a>2. 并查集</h3><p>两个基本操作：</p><ul><li>判断两个元素是不是在一个集合中</li><li>将两个集合合并</li></ul><p>关键函数：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p[x] != x) p[x] = <span class="built_in">find</span>(p[x]);</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三、代码"><a href="#三、代码" class="headerlink" title="三、代码"></a>三、代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">110</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> p[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p[x] != x) p[x] = <span class="built_in">find</span>(p[x]);</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">if</span> (n != m) cout &lt;&lt; <span class="string">&quot;NO&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">            p[i] = i;</span><br><span class="line">        <span class="type">int</span> cnt = n; <span class="comment">// 存储集合的数量</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> line = <span class="number">0</span>; line &lt; m; line ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> a, b;</span><br><span class="line">            cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">find</span>(a) != <span class="built_in">find</span>(b))</span><br><span class="line">            &#123;</span><br><span class="line">                cnt -- ;</span><br><span class="line">                p[<span class="built_in">find</span>(a)] = <span class="built_in">find</span>(b);</span><br><span class="line">            &#125;    </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cnt == <span class="number">1</span>) cout &lt;&lt; <span class="string">&quot;YES&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;NO&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> AcWing </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图论 </tag>
            
            <tag> 并查集 </tag>
            
            <tag> 基环树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图中点的层次</title>
      <link href="/2024/07/14/%E5%9B%BE%E4%B8%AD%E7%82%B9%E7%9A%84%E5%B1%82%E6%AC%A1/"/>
      <url>/2024/07/14/%E5%9B%BE%E4%B8%AD%E7%82%B9%E7%9A%84%E5%B1%82%E6%AC%A1/</url>
      
        <content type="html"><![CDATA[<h3 id="一、题目"><a href="#一、题目" class="headerlink" title="一、题目"></a>一、题目</h3><blockquote><p>宽搜模板题：<a href="https://www.acwing.com/problem/content/849/">https://www.acwing.com/problem/content/849/</a></p></blockquote><p>给定一个 $n$ 个点 $m$ 条边的有向图，图中可能存在重边和自环。</p><p>所有边的长度都是 $1$，点的编号为 $1 \sim n$。</p><p>请你求出 $1$ 号点到 $n$ 号点的最短距离，如果从 $1$ 号点无法走到 $n$ 号点，输出 $-1$。</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行包含两个整数 $n$ 和 $m$。</p><p>接下来 $m$ 行，每行包含两个整数 $a$ 和 $b$，表示存在一条从 $a$ 走到 $b$ 的长度为 $1$ 的边。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>输出一个整数，表示 $1$ 号点到 $n$ 号点的最短距离。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>$1 \le n,m \le 10^5$</p><h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4 5</span><br><span class="line">1 2</span><br><span class="line">2 3</span><br><span class="line">3 4</span><br><span class="line">1 3</span><br><span class="line">1 4</span><br></pre></td></tr></table></figure><h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure><h2 id="二、题解"><a href="#二、题解" class="headerlink" title="二、题解"></a>二、题解</h2><h3 id="1-memset-初始化"><a href="#1-memset-初始化" class="headerlink" title="1. memset() 初始化"></a>1. <code>memset()</code> 初始化</h3><p>在对数组进行初始化时，可能会用到 <code>memset()</code>，其初始化特点是<strong>按字节去逐个初始化</strong>，可以将数组初始化为 $-1$、$0$、$0x3f$。其中，使用 $-1$、$0$、$0x3f$ 初始化时，分别能够将数组初始化为 $-1$、$0$、无穷大。（如果要初始化为其他值，则使用 <code>for循环</code> 较好。）</p><blockquote><p>比如，把数组初始化为 <code>100</code>，如果使用 <code>memset()</code> 进行初始化：<br>因为 <code>100</code> 的二进制表示为 <code>01100100</code>，那么使用 <code>memset()</code> 初始化后，该数组中每一项的二进制表示为 <code>01100100 01100100 01100100 01100100</code>，转换成十进制为 <code>1684300900</code>，而不是 <code>100</code>。</p></blockquote><p><strong>为什么使用<code>0x3f3f3f3f</code>定义无穷大呢？</strong></p><p>因为<code>0x3f3f3f3f</code>转换成十进制为<code>1061109567</code>，是<code>10^9</code>级别的，其<strong>足够大</strong>；其次，也是最重要的，<code>0x3f3f3f3f + 0x3f3f3f3f</code>等于<code>0x7e7e7e7e</code>，<strong>不会爆int</strong>。</p><blockquote><p>在很多算法中，我们需要进行诸如<code>dist[j] &gt; dist[t] + w[t][j]</code>之类的判断，如果两个大于<code>0x3f3f3f3f</code>的数相加，那么后果不堪设想。因为溢出并不会报错，算法逻辑复杂，我们往往很难定位真正的错误。</p></blockquote><blockquote><p>参考链接: <a href="https://blog.csdn.net/2301_79599253/article/details/135737272">https://blog.csdn.net/2301_79599253/article/details/135737272</a> 、<a href="https://cloud.tencent.com/developer/article/1877662">https://cloud.tencent.com/developer/article/1877662</a></p></blockquote><h3 id="2-图的存储：邻接表"><a href="#2-图的存储：邻接表" class="headerlink" title="2. 图的存储：邻接表"></a>2. 图的存储：邻接表</h3><p>使用邻接表存储图，其中：<br>用<code>h[]</code>保存各个节点能到的第一个节点的编号，开始时，<code>h[]</code>全部为<code>-1</code>；用<code>e[]</code>保存节点编号，<code>ne[]</code>保存<code>e[]</code>对应位置的下一个节点所在的索引；用<code>idx</code>保存下一个<code>e[]</code>中，可以放入节点位置的索引。</p><p>插入边使用的头插法，例如插入：<code>a-&gt;b</code>。首先把<code>b</code>节点存入<code>e</code>数组，<code>e[idx] = b</code>；然后<code>b</code>节点的后继是<code>h[a]</code>，<code>ne[idx] = h[a]</code>；最后，<code>a</code>的后继更新为<code>b</code>节点的编号，<code>h[a] = idx</code>，索引指向下一个可以存储节点的位置，<code>idx ++</code>。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void add(int a, int b)      // 在邻接表中添加 a-&gt;b 的有向边</span><br><span class="line">&#123;</span><br><span class="line">    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-邻接表的BFS遍历"><a href="#3-邻接表的BFS遍历" class="headerlink" title="3. 邻接表的BFS遍历"></a>3. 邻接表的BFS遍历</h3><p>从<code>h[fro]</code>指向的头节点开始遍历，以<code>i = ne[i]</code>更新变量<code>i</code>，以<code>i != -1</code>为结束条件，遍历以<code>fro</code>节点为起点的有向边，分别更新距离、队列和是否被访问。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for (int i = h[fro]; i != -1; i = ne[i] )   // 遍历和fro节点存在有向边的节点 fro-&gt;</span><br><span class="line">&#123;</span><br><span class="line">int las = e[i];     // 后节点</span><br><span class="line">if (!st[las])</span><br><span class="line">&#123;</span><br><span class="line">dist[las] = dist[fro] + 1;      // 更新距离</span><br><span class="line">q.push(las);        // 更新队列</span><br><span class="line">st[las] = true;     // 更新是否被访问</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-如何求出距离？如何避免重环和自环？"><a href="#4-如何求出距离？如何避免重环和自环？" class="headerlink" title="4. 如何求出距离？如何避免重环和自环？"></a>4. 如何求出距离？如何避免重环和自环？</h3><p>对于题目中的距离的求解，可以根据当前遍历层距离计算下一层距离。初始状态下，所有距离的初值为<code>0x3f3f3f3f</code>，从第一个节点开始遍历，故第一个节点的距离为<code>0</code>。比如，当前遍历的节点为<code>fro</code>，且通过计算已经得出到达其的最短距离，则其下一个节点的距离为<code>dist[fro] + 1</code>。</p><p>为了避免重环和自环，可以通过一个标志位（该节点是否被访问过），使每个节点只遍历一次。在更新距离的过程中，不断更新此标志位。</p><h3 id="5-queue-相关"><a href="#5-queue-相关" class="headerlink" title="5. queue 相关"></a>5. <code>queue</code> 相关</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;quque&gt;// 头文件</span><br><span class="line">queue&lt;int&gt; q;// 创建一个名为q，存储int型数据的队列</span><br><span class="line">q.size();// 返回当前队列的大小</span><br><span class="line">int a = 10;</span><br><span class="line">q.push(a);// 队尾添加一个元素</span><br><span class="line">q.front();// 返回队首元素</span><br><span class="line">q.pop();// 弹出队首元素</span><br><span class="line">q.empty();// 如果队列为空 返回true</span><br></pre></td></tr></table></figure><h2 id="三、代码"><a href="#三、代码" class="headerlink" title="三、代码"></a>三、代码</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N = 100010;</span><br><span class="line">int n, m;</span><br><span class="line">int h[N], e[N], ne[N], idx;     // 邻接表数据结构</span><br><span class="line">int dist[N];    // dist存储距离</span><br><span class="line">bool st[N];     // st标记是否走到过</span><br><span class="line"></span><br><span class="line">void add(int a, int b)      // 在邻接表中添加 a-&gt;b 的有向边</span><br><span class="line">&#123;</span><br><span class="line">    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void bfs()  // 宽搜</span><br><span class="line">&#123;</span><br><span class="line">    memset(dist, 0x3f, sizeof dist);    // 初始化距离为无穷大</span><br><span class="line">    dist[1] = 0;    // 从1开始，到1的距离为0</span><br><span class="line">    queue&lt;int&gt; q;</span><br><span class="line">    q.push(1), st[1] = true;    // 已经访问第一个节点，放入队列，且标记为访问</span><br><span class="line">    while (q.size())    // 如果队列非空</span><br><span class="line">    &#123;</span><br><span class="line">        int fro = q.front();    // 提取队首元素</span><br><span class="line">        q.pop();</span><br><span class="line">        for (int i = h[fro]; i != -1; i = ne[i] )   // 遍历和fro节点存在有向边的节点 fro-&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            int las = e[i];     // 后节点</span><br><span class="line">            if (!st[las])</span><br><span class="line">            &#123;</span><br><span class="line">                dist[las] = dist[fro] + 1;      // 更新距离</span><br><span class="line">                q.push(las);        // 更新队列</span><br><span class="line">                st[las] = true;     // 更新是否被访问</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    memset(h, -1, sizeof h);    // 初始化邻接矩阵的索引</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    for (int i = 0; i &lt; m; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        int a, b;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        add(a, b);      // 添加有向边</span><br><span class="line">    &#125;</span><br><span class="line">    bfs();</span><br><span class="line">    cout &lt;&lt; (dist[n] == 0x3f3f3f3f ? -1 : dist[n]) &lt;&lt; endl;     // 输出距离</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> AcWing </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图论 </tag>
            
            <tag> BFS </tag>
            
            <tag> 图的存储 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>解决github访问速度慢的问题</title>
      <link href="/2024/07/11/%E8%A7%A3%E5%86%B3github%E8%AE%BF%E9%97%AE%E9%80%9F%E5%BA%A6%E6%85%A2%E7%9A%84%E9%97%AE%E9%A2%98/"/>
      <url>/2024/07/11/%E8%A7%A3%E5%86%B3github%E8%AE%BF%E9%97%AE%E9%80%9F%E5%BA%A6%E6%85%A2%E7%9A%84%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="一、手动修改"><a href="#一、手动修改" class="headerlink" title="一、手动修改"></a>一、手动修改</h2><h3 id="1-查询-http-github-com-的ip地址"><a href="#1-查询-http-github-com-的ip地址" class="headerlink" title="1. 查询 http://github.com 的ip地址"></a>1. 查询 <a href="http://github.com/">http://github.com</a> 的ip地址</h3><p>链接：<a href="http://github.global.ssl.fastly.net.ipaddress.com/#ipinfo">http://github.global.ssl.fastly.net.ipaddress.com/#ipinfo</a></p><p><img src="https://behnam-1322901478.cos.ap-beijing.myqcloud.com/blog/3480256-20240713202752354-1976739339.png"></p><p>站长之家 <a href="http://ip.tool.chinaz.com/github.com">http://ip.tool.chinaz.com/github.com</a><br>便民查询网 <a href="https://ip.51240.com/github.com__ip/">https://ip.51240.com/github.com__ip/</a><br>IPAdress.com <a href="https://github.com.ipaddress.com/">https://github.com.ipaddress.com/</a></p><blockquote><p>IP: 140.82.113.3</p></blockquote><h3 id="2-查询-https-github-global-ssl-fastly-net-的IP地址"><a href="#2-查询-https-github-global-ssl-fastly-net-的IP地址" class="headerlink" title="2. 查询 https://github.global.ssl.fastly.net 的IP地址"></a>2. 查询 <a href="https://github.global.ssl.fastly.net/">https://github.global.ssl.fastly.net</a> 的IP地址</h3><p>链接：<a href="https://github.com.ipaddress.com/#ipinfo" title="https://github.com.ipaddress.com/#ipinfo">https://github.com.ipaddress.com/#ipinfo</a></p><p><img src="https://behnam-1322901478.cos.ap-beijing.myqcloud.com/blog/3480256-20240713202735685-510433277.png"></p><blockquote><p>IP: 151.101.1.6</p></blockquote><h3 id="3-修改本地-hosts-文件映射上面查找到的-IP"><a href="#3-修改本地-hosts-文件映射上面查找到的-IP" class="headerlink" title="3. 修改本地 hosts 文件映射上面查找到的 IP"></a>3. 修改本地 hosts 文件映射上面查找到的 IP</h3><h4 id="3-1-修改-hosts-文件的权限"><a href="#3-1-修改-hosts-文件的权限" class="headerlink" title="3.1 修改 hosts 文件的权限"></a>3.1 修改 hosts 文件的权限</h4><p>在<code>C:\Windows\System32\drivers\etc</code>路径下，找到<code>hosts</code>文件；右击-&gt;hosts-&gt;属性-&gt;安全-&gt;编辑-&gt;点击Users-&gt;在Users的权限“写入”后面打勾。</p><h4 id="3-2-添加映射关系"><a href="#3-2-添加映射关系" class="headerlink" title="3.2 添加映射关系"></a>3.2 添加映射关系</h4><p>右击-&gt;hosts-&gt;打开方式-&gt;选定记事本（或者你喜欢的编辑器）-&gt;在末尾处添加以下内容：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">151.101.1.6  github.global.ssl.fastly.net</span><br><span class="line">140.82.113.3  github.com</span><br></pre></td></tr></table></figure><p><img src="https://behnam-1322901478.cos.ap-beijing.myqcloud.com/blog/3480256-20240713202635446-1188331948.png"></p><h4 id="3-3-改回-hosts-文件的权限"><a href="#3-3-改回-hosts-文件的权限" class="headerlink" title="3.3 改回 hosts 文件的权限"></a>3.3 改回 hosts 文件的权限</h4><p>右击-&gt;hosts-&gt;属性-&gt;安全-&gt;编辑-&gt;点击Users-&gt;在Users的权限“写入”后面取消打勾。</p><blockquote><p>参考链接：<a href="https://cloud.tencent.com/developer/article/1835785?shareByChannel=link">https://cloud.tencent.com/developer/article/1835785?shareByChannel=link</a> 、<a href="https://blog.csdn.net/Jasonkun_3/article/details/114435640">https://blog.csdn.net/Jasonkun_3/article/details/114435640</a></p></blockquote><h2 id="二、自动修改"><a href="#二、自动修改" class="headerlink" title="二、自动修改"></a>二、自动修改</h2><h3 id="1-下载并安装-SwitchHosts"><a href="#1-下载并安装-SwitchHosts" class="headerlink" title="1. 下载并安装 SwitchHosts"></a>1. 下载并安装 SwitchHosts</h3><p><a href="https://github.com/oldj/SwitchHosts">https://github.com/oldj/SwitchHosts</a></p><h3 id="2-修改hosts文件权限"><a href="#2-修改hosts文件权限" class="headerlink" title="2. 修改hosts文件权限"></a>2. 修改hosts文件权限</h3><p>右击-&gt;hosts-&gt;属性-&gt;安全-&gt;编辑-&gt;点击Users-&gt;给Users用户添加全部权限</p><h3 id="3-配置-SwitchHosts"><a href="#3-配置-SwitchHosts" class="headerlink" title="3. 配置 SwitchHosts"></a>3. 配置 SwitchHosts</h3><p>Hosts 类型: Remote</p><p>Hosts 标题: 随意</p><p>URL: <a href="https://raw.hellogithub.com/hosts">https://raw.hellogithub.com/hosts</a></p><p>自动刷新: 最好选 1 小时</p>]]></content>
      
      
      <categories>
          
          <category> 环境配置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> github </tag>
            
            <tag> hosts </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
